{
 "bad": [
  "CertManager",
  "Cls",
  "Queue.Empty",
  "Queue.Queue",
  "__future__.division",
  "__future__.print_function",
  "_chunker",
  "_get_partition_msgs",
  "_latest_partition_offsets_by_reading",
  "_rd_kafka.Consumer",
  "_rd_kafka.Producer",
  "argparse",
  "argparse.ArgumentDefaultsHelpFormatter",
  "argparse.ArgumentParser",
  "argparse.FileType",
  "balancedconsumer.BalancedConsumer",
  "base.Request",
  "base.Response",
  "broker.Broker",
  "broker.Broker.from_metadata",
  "calendar",
  "calendar.timegm",
  "check_partitions",
  "cls",
  "collections.defaultdict",
  "collections.deque",
  "collections.namedtuple",
  "common.CompressionType.GZIP",
  "common.CompressionType.LZ4",
  "common.CompressionType.NONE",
  "common.CompressionType.SNAPPY",
  "common.EPOCH.total_seconds",
  "common.Message",
  "common.Message.decode",
  "common.OffsetType.EARLIEST",
  "common.OffsetType.LATEST",
  "compat.IS_PYPY",
  "compat.PY3",
  "compat.buffer",
  "compat.iteritems",
  "compat.range",
  "connection.BrokerConnection",
  "consumer_timed_out",
  "contextlib.contextmanager",
  "datetime",
  "datetime.datetime",
  "datetime.datetime.now",
  "datetime.datetime.strptime",
  "datetime.timedelta",
  "errno",
  "errno.ECONNREFUSED",
  "errno.EEXIST",
  "exceptions.ConsumerStoppedException",
  "exceptions.ERROR_CODES",
  "exceptions.GroupCoordinatorNotAvailable",
  "exceptions.GroupCoordinatorNotAvailable.ERROR_CODE",
  "exceptions.GroupLoadInProgress.ERROR_CODE",
  "exceptions.IllegalGeneration.ERROR_CODE",
  "exceptions.InvalidMessageSize",
  "exceptions.KafkaException",
  "exceptions.LeaderNotAvailable.ERROR_CODE",
  "exceptions.LeaderNotFoundError",
  "exceptions.MessageSetDecodeFailure",
  "exceptions.MessageSizeTooLarge",
  "exceptions.NoBrokersAvailableError",
  "exceptions.NotCoordinatorForGroup.ERROR_CODE",
  "exceptions.NotLeaderForPartition.ERROR_CODE",
  "exceptions.OffsetMetadataTooLarge",
  "exceptions.OffsetMetadataTooLarge.ERROR_CODE",
  "exceptions.OffsetOutOfRangeError.ERROR_CODE",
  "exceptions.OffsetRequestFailedError",
  "exceptions.PartitionOwnedError",
  "exceptions.ProduceFailureError",
  "exceptions.ProducerQueueFullError",
  "exceptions.ProducerStoppedException",
  "exceptions.RebalanceInProgress.ERROR_CODE",
  "exceptions.RequestTimedOut.ERROR_CODE",
  "exceptions.SocketDisconnectedError",
  "exceptions.UnicodeException",
  "exceptions.UnknownError.ERROR_CODE",
  "exceptions.UnknownMemberId.ERROR_CODE",
  "exceptions.UnknownTopicOrPartition",
  "exceptions.UnknownTopicOrPartition.ERROR_CODE",
  "f",
  "f1",
  "f2",
  "fn",
  "functools.partial",
  "get_queue_readers",
  "gevent",
  "gevent.event",
  "gevent.lock",
  "gevent.queue",
  "gevent.socket",
  "gevent.socket.error",
  "gevent.socket.gaierror",
  "gevent.spawn",
  "gzip",
  "gzip.GzipFile",
  "handlers.GEventHandler",
  "handlers.RequestHandler",
  "hash_func",
  "hashlib.sha1",
  "helpers.rdk_ssl_config",
  "io.BytesIO",
  "itertools",
  "itertools.chain.from_iterable",
  "itertools.islice",
  "json",
  "json.dumps",
  "json.loads",
  "kafka_tools.main",
  "kazoo.client.KazooClient",
  "kazoo.exceptions.NoNodeException",
  "kazoo.exceptions.NodeExistsError",
  "kazoo.handlers.gevent.SequentialGeventHandler",
  "kazoo.recipe.watchers.ChildrenWatch",
  "logging",
  "logging.DEBUG",
  "logging.NullHandler",
  "logging.basicConfig",
  "logging.getLogger",
  "lz4.frame",
  "lz4.frame.compress",
  "lz4.frame.decompress",
  "lz4f",
  "lz4f.compressFrame",
  "managedbalancedconsumer.ManagedBalancedConsumer",
  "math",
  "math.floor",
  "message.MessageSet.decode",
  "mock",
  "mock.MagicMock",
  "mock.Mock",
  "operator",
  "operator.attrgetter",
  "os",
  "os.chdir",
  "os.environ",
  "os.environ.get",
  "os.getcwd",
  "os.listdir",
  "os.makedirs",
  "os.path.exists",
  "os.path.join",
  "os.unlink",
  "p_to_str",
  "partition.Partition",
  "pkg_resources",
  "pkg_resources.parse_version",
  "platform",
  "platform.python_implementation",
  "producer.Producer",
  "protocol.API_VERSIONS_080",
  "protocol.API_VERSIONS_090",
  "protocol.ApiVersionsRequest",
  "protocol.ApiVersionsResponse.get_version_impl",
  "protocol.ConsumerGroupProtocolMetadata",
  "protocol.CreateTopicsRequest",
  "protocol.CreateTopicsResponse",
  "protocol.DeleteTopicsRequest",
  "protocol.DeleteTopicsResponse",
  "protocol.DescribeGroupsRequest",
  "protocol.DescribeGroupsResponse",
  "protocol.FetchRequest.get_version_impl",
  "protocol.FetchResponse.get_version_impl",
  "protocol.GroupCoordinatorRequest",
  "protocol.GroupCoordinatorResponse",
  "protocol.HeartbeatRequest",
  "protocol.HeartbeatResponse",
  "protocol.JoinGroupRequest",
  "protocol.JoinGroupResponse",
  "protocol.LeaveGroupRequest",
  "protocol.LeaveGroupResponse",
  "protocol.ListGroupsRequest",
  "protocol.ListGroupsResponse",
  "protocol.ListOffsetRequest.get_version_impl",
  "protocol.ListOffsetResponse.get_version_impl",
  "protocol.MemberAssignment",
  "protocol.Message",
  "protocol.MetadataRequest.get_version_impl",
  "protocol.MetadataResponse.get_version_impl",
  "protocol.OffsetCommitRequest",
  "protocol.OffsetCommitResponse",
  "protocol.OffsetFetchRequest.get_version_impl",
  "protocol.OffsetFetchResponse.get_version_impl",
  "protocol.PartitionFetchRequest",
  "protocol.PartitionOffsetCommitRequest",
  "protocol.PartitionOffsetFetchRequest",
  "protocol.PartitionOffsetRequest",
  "protocol.ProduceRequest",
  "protocol.ProduceResponse",
  "protocol.SyncGroupRequest",
  "protocol.SyncGroupResponse",
  "pykafka.balancedconsumer.OffsetType.EARLIEST",
  "pykafka.balancedconsumer.OffsetType.LATEST",
  "pykafka.common.CompressionType.GZIP",
  "pykafka.common.CompressionType.SNAPPY",
  "pykafka.common.OffsetType.LATEST",
  "pykafka.producer.CompressionType.GZIP",
  "pykafka.producer.CompressionType.LZ4",
  "pykafka.producer.CompressionType.NONE",
  "pykafka.producer.CompressionType.SNAPPY",
  "pykafka.protocol.Message.__slots__",
  "pykafka.rdkafka._rd_kafka",
  "pykafka.rdkafka._rd_kafka.Consumer",
  "pykafka.rdkafka._rd_kafka._thread_cnt",
  "pykafka.rdkafka._rd_kafka._wait_destroyed",
  "pykafka.simpleconsumer.OffsetType.EARLIEST",
  "pykafka.simpleconsumer.OffsetType.LATEST",
  "pykafka.utils.__init__.VERSIONS_CACHE",
  "pytest",
  "pytest.mark.skip",
  "pytest.mark.skipif",
  "pytest.mark.xfail",
  "pytest.raises",
  "pytest.skip",
  "queue.Empty",
  "queue.Queue",
  "random",
  "random.random",
  "random.randrange",
  "random.shuffle",
  "ref",
  "request_class",
  "shutil",
  "shutil.rmtree",
  "signal",
  "signal.SIGINT",
  "signal.signal",
  "simpleconsumer.SimpleConsumer",
  "six.integer_types",
  "six.reraise",
  "snappy",
  "socket",
  "socket.create_connection",
  "socket.error",
  "socket.gaierror",
  "socket.gethostname",
  "ssl",
  "ssl.CERT_REQUIRED",
  "ssl.PROTOCOL_TLSv1",
  "ssl.create_default_context",
  "ssl.wrap_socket",
  "stop_owned_brokers",
  "struct",
  "struct.calcsize",
  "struct.error",
  "struct.pack",
  "struct.pack_into",
  "struct.unpack",
  "struct.unpack_from",
  "subprocess",
  "subprocess.PIPE",
  "subprocess.Popen",
  "subprocess.check_call",
  "subprocess.check_output",
  "sys",
  "sys.exc_info",
  "sys.exit",
  "sys.stdout",
  "sys.version_info",
  "tabulate",
  "tabulate.tabulate",
  "tempfile",
  "testinstances.exceptions.ProcessNotStartingError",
  "testinstances.managed_instance.ManagedInstance",
  "testinstances.utils",
  "testinstances.utils.Popen",
  "testinstances.utils.STDOUT",
  "threading",
  "threading.Condition",
  "threading.Event",
  "threading.Lock",
  "threading.RLock",
  "threading.Semaphore",
  "threading.Thread",
  "threading.local",
  "time",
  "time.sleep",
  "time.time",
  "topic.Topic",
  "topic_ref",
  "types",
  "types.MethodType",
  "unittest",
  "unittest.TestCase",
  "unittest.main",
  "unittest2",
  "unittest2.TestCase",
  "unittest2.main",
  "unlock_partitions",
  "utils.ApiVersionAware",
  "utils.Serializable",
  "utils.compat.Empty",
  "utils.compat.Queue",
  "utils.compat.Semaphore",
  "utils.compat.buffer",
  "utils.compat.get_bytes",
  "utils.compat.get_string",
  "utils.compat.iteritems",
  "utils.compat.iterkeys",
  "utils.compat.itervalues",
  "utils.compat.range",
  "utils.compression.decode_gzip",
  "utils.compression.decode_lz4",
  "utils.compression.decode_lz4_old_kafka",
  "utils.compression.decode_snappy",
  "utils.compression.encode_gzip",
  "utils.compression.encode_lz4",
  "utils.compression.encode_lz4_old_kafka",
  "utils.compression.encode_snappy",
  "utils.error_handlers.build_parts_by_error",
  "utils.error_handlers.handle_partition_responses",
  "utils.error_handlers.raise_error",
  "utils.error_handlers.valid_int",
  "utils.socket.recvall_into",
  "utils.struct_helpers.unpack_from",
  "uuid",
  "uuid.uuid4",
  "verify_extras",
  "weakref",
  "weakref.proxy",
  "weakref.ref",
  "xxhash",
  "zlib.crc32"
 ],
 "deps": {
  "CertManager": [],
  "Cls": [],
  "Queue": [],
  "__future__": [],
  "_chunker": [],
  "_get_partition_msgs": [],
  "_latest_partition_offsets_by_reading": [],
  "_rd_kafka": [],
  "argparse": [],
  "balancedconsumer": [],
  "base": [],
  "broker": [],
  "calendar": [],
  "check_partitions": [],
  "cls": [],
  "collections": [],
  "common": [],
  "compat": [],
  "connection": [],
  "consumer_timed_out": [],
  "contextlib": [],
  "datetime": [],
  "errno": [],
  "exceptions": [],
  "f": [],
  "f1": [],
  "f2": [],
  "fn": [],
  "functools": [],
  "get_queue_readers": [],
  "gevent": [],
  "gzip": [],
  "handlers": [],
  "hash_func": [],
  "hashlib": [],
  "helpers": [],
  "io": [],
  "itertools": [],
  "json": [],
  "kafka_tools": [],
  "kazoo": [],
  "logging": [],
  "lz4": [],
  "lz4f": [],
  "managedbalancedconsumer": [],
  "math": [],
  "message": [],
  "mock": [],
  "operator": [],
  "os": [],
  "p_to_str": [],
  "partition": [],
  "pkg_resources": [],
  "platform": [],
  "producer": [],
  "protocol": [],
  "pykafka": [],
  "pytest": [],
  "queue": [],
  "random": [],
  "ref": [],
  "request_class": [],
  "shutil": [],
  "signal": [],
  "simpleconsumer": [],
  "six": [],
  "snappy": [],
  "socket": [],
  "ssl": [],
  "stop_owned_brokers": [],
  "struct": [],
  "subprocess": [],
  "sys": [],
  "tabulate": [],
  "tempfile": [],
  "testinstances": [],
  "threading": [],
  "time": [],
  "topic": [],
  "topic_ref": [],
  "types": [],
  "unittest": [],
  "unittest2": [],
  "unlock_partitions": [],
  "utils": [],
  "uuid": [],
  "verify_extras": [],
  "weakref": [],
  "xxhash": [],
  "zlib": []
 }
}